浅谈git

花了两天时间把git大致学了一遍，心里有一些自己的理解，于是写下来。

要学习一门学科，语言或者一种工具，首先要知道我们所学为何物，那么问题来了（不是蓝翔，别想歪了），GIT是什么？

用浅显的话来说嘛，GIT是目前世界上最先进的分布式版本控制系统。这样问题又来了（不想蓝翔会死啊？），什么是版本控制系统？

版本控制系统提供完备的版本管理功能，用于存储、追踪目录（文件夹）和文件的修改历史，是软件开发者的必备工具，是软件公司的基础设施。版本控制软件的最高目标，是支持软件公
司的配置管理活动，追踪多个版本的开发和维护活动，及时发布软件。好吧这些都是我百度来的，有点过于书面了，那么简单点举个例子，什么是版本控制系统呢？大家都是程序猿，自然
要写代码，写工程，如果某一天，女神请你帮她写一项工（别问我为什么女神要找你，这是剧情），对于编程大牛你而言，这只是小事，轻轻松松就解决了，把成果发给她之后你发现程序
无法运行，花了九牛二虎之力，你发现某几个地方代码有点小错，成功解决掉问题的你过于兴奋，只是习惯性的保存了代码，并没有吧修正过来的程序发给女神。于是第二天她抱着电脑来
找你，问你程序为什么用不了，哪里有错，这时你想起了自己昨天改了几处，然而睡了一觉早就忘了代码具体是哪里有问题了，于是几个小错误也花了你大半天时间来找，让女神干等了很
久，后来就在没有找过你。（我废话怎么这么多）这个时候，如果你有一个版本控制系统，情况也许会好得多，因为这个版本控制系统会告诉你，你修改过哪里，什么时候修改的，一眼就
能找到昨天的错误，然后让女神……（编不下去了……妈的废话太多了）

最后废话一下，所以说，什么是版本控制系统？

就是可以记录修改的工具。

之前说到GIT是目前世界上一流的分布式版本控制系统，那么除了分布式，还有什么式呢，各有什么优劣呢？

我所知的，版本控制系统分为分布式和集中式。

集中式：
集中式版本控制系统的版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在
互联网上，遇到网速慢的话，你就等着扣奖金吧。而且版本库放在中央服务器中，一旦发生什么不可抗力的事损坏了这个服务器，资料就毁掉了。

分布式：
与集中式相比，分布式版本控制系统的安全性要高得多，首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，因为每个人电脑里都有完整的版
本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。也因为此，你工作的时候，甚至不需要联网，因为版本库就在你自己的电脑上。

说了这么多了，差不过该进入正题了，那就是GIT的学习，要学习这个软件，自然要安装它，Linux和Unix不提，在Windows上安装GIT也是很方便简单的事http://msysgit.github.io/下
载，安装即可，不过在安装完成后需要进行最后一步设置
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
这样一来，Windows中的GIT就算是成功安装了

那么我们开始学习GIT之旅

第一步，创建一个版本库

那么问题来了（蓝翔蓝翔蓝翔蓝翔~~~~~~~），版本库是什么？

好问题，蓝……呸！版本库是什么呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，
以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

创建一个版本库是很简单的事，创建一个空目录，然后通过GIT BUSH进入（命令是cmd的命令），接下来我们将学到GIT的第一个常用命令

git init —— 创建版本库

创建了版本库，我们就该学习把自己的资料添加到库中，于是接下来我们学习两个命令

git add + FileName —— 添加文件到暂存区（问题又来了，不是蓝翔不是新东方，什么是暂存区，这个暂时不管，待会儿会讲到）

git commit -m “备注” —— 提交文件到仓库（tip：这个-m没有也是可以的，但不建议这样，因为版本控制系统就是想让你记住自己的修改而定的，如果不备注那么很容易忘记）

这里要提一下，所谓文件管理系统，其实只能追踪文件的修改，比如TXT的文件，任何二进制文件的改变，是无法追踪的，比如一个图片，向其内部添加一些东西，使其变大，
系统虽然能追踪出图片变大了，却不能看到是什么地方发什么了改变。很不幸的是，Windows中的word也是二进制格式，而且微软犯了个很傻比的错误，导致他们的TXT也会出现各种
莫名其妙的错误，所以建议使用notepad++，只要用UTF-8无BOM格式编码就行了

当我们把文件添加进入仓库之后，继续修改文件，这时候另一个命令来了

git status —— 查看工作区和暂存区当前状态（不仅是暂存区，现在又来了个工作区，不急，待我慢慢说来）

当使用git status命令查看到文件被修改，但还没有提交的时候，就可以使用另一个命令来查看文件的修改

git diff + FileName —— 查看文件修改（顾名思义，diff是different的缩写）

将修改的文件提交到库中的之后你恍然发现自己提交的文件有错，需要修正，但是已经提交了怎么办呢？两个全新的命令来到眼前

git log —— 查看历史版本

git reset --hard HEAD^ 版本回退（回退几个版本，就几个^）

于是你使用版本回退命令回到上一个版本，紧接着你发现，你没有犯错，是你搞错了（没错，我特么就是在逗你）

怎么办呢，别担心，版本不但能回退，还能前进

这个时候两个有两个方法，一是向上拉，看看之前那个版本的版本ID，什么是版本ID，问的哈，就是那一串长长的奇葩数字，找到以后，取前7位（一般来说超过5位就行了）

git reset --hard id

这样就万事大吉了，如果你不小心把窗口查了，不能想上去查找版本ID怎么办？也没关系，我会教给你一个新的命令，将拯救你与水火之中

git reflog —— 查看命令历史

使用这个命令之后一样能找到之前的版本号，然后方法一样就能让版本移动了

细心的朋友还会发现，GIT版本不论是前进还是回退都快的一逼，这是为什么呢？

我们便深入了解一下GIT版本原理，之前的命令有使用到HEAD，学过数据结构的大概会反应出来，没错，就是链表，版本的回退与前进仅仅是改变一下链表next域的指向，所以才会那么快。
既然扯到这里，那我们便提一提之前遇到的两个区

工作区：
就是之前创建GIT仓库的那个文件目录，这个目录在电脑上是可视的，可以假想版本库是一座仓库，而工作区就是仓库以外，围墙以内的区域。

缓存区：
之前提到版本库，版本库中最重要的东西之一就是缓存区，当我们使用add命令添加文件的时候，其实就是把文件添加到这里来，接着使用commit之后才会吧文件放入仓库，为什么要设计
这么一个缓存区呢，意义何在？
我们举个例子就知道了
修改了a文件
git add .
再一次修改a文件
这个时候你git checkout -- a,a文件回到暂存时保存的状态,也就是第2步的状态
如果需要回到未修改的状态,需要运行git reset HEAD a
觉得可以用它防止git checkout -- 误操作
而且,git diff优先把修改的和暂存比较,没有暂存时才拿上次提交的文件比较

上面的例子提到了一个新的命令，这个命令是什么作用呢

git checkout -- FileName —— 丢弃工作区的修改

如果要删除文件，又是什么命令呢

git rm -- FileName —— 删除文件